# .github/workflows/deploy-k8s-infrastructure.yml
# Place this in your k8s-manifests repository
name: Deploy K8s Infrastructure Changes

on:
  push:
    branches: [ main ]
    paths:
      - 'k8s/configmaps/**'
      - 'k8s/services/**'
      - 'k8s/ingress/**'
      - 'k8s/pvc/**'
      - 'k8s/secrets/**'
      - 'k8s/network-policies/**'
      - 'k8s/hpa/**'
      - 'k8s/statefulsets/**'
      # Exclude deployment files - handled by service CDs
      - '!k8s/deployments/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      resource_type:
        description: 'Type of resource to deploy'
        required: true
        default: 'all'
        type: choice
        options:
        - all
        - configmaps
        - services
        - ingress
        - secrets
        - network-policies
        - hpa
        - statefulsets
        - mysql-only

env:
  KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}

jobs:
  deploy-infrastructure:
    name: Deploy Infrastructure Changes
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout k8s manifests
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl with enhanced debugging
        run: |
          echo "üîç Checking KUBE_CONFIG_DATA secret..."
          
          # Check if secret exists and has content
          if [ -z "${{ env.KUBE_CONFIG_DATA }}" ]; then
            echo "‚ùå KUBE_CONFIG_DATA secret is empty or not set!"
            echo ""
            echo "üîß To fix this issue:"
            echo "1. Run: cat ~/.kube/config"
            echo "2. Run: cat ~/.kube/config | base64 -w 0"
            echo "3. Copy the output and add it as KUBE_CONFIG_DATA secret in GitHub"
            echo "4. Make sure to copy the ENTIRE base64 string (it should be very long)"
            exit 1
          fi
          
          echo "‚úÖ KUBE_CONFIG_DATA secret found"
          
          # Decode the kubeconfig
          echo "üîß Decoding kubeconfig..."
          echo "${{ env.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig
          
          # Check if decoded file has content
          if [ ! -s kubeconfig ]; then
            echo "‚ùå Decoded kubeconfig file is empty!"
            echo "This usually means the base64 encoding was corrupted."
            echo ""
            echo "üîß Please re-create the secret:"
            echo "1. cat ~/.kube/config | base64 -w 0 | tr -d '\n'"
            echo "2. Copy the ENTIRE output (should be one long line)"
            echo "3. Update KUBE_CONFIG_DATA secret in GitHub"
            exit 1
          fi
          
          # Set permissions and environment
          chmod 600 kubeconfig
          export KUBECONFIG=kubeconfig
          
          echo "‚úÖ Kubeconfig file created and configured"
          
          # Validate kubeconfig syntax
          echo "üîç Validating kubeconfig syntax..."
          if ! kubectl config view > /dev/null 2>&1; then
            echo "‚ùå Invalid kubeconfig format!"
            echo "The kubeconfig file has syntax errors."
            echo "Please check your original kubeconfig file and re-encode it."
            exit 1
          fi
          
          echo "‚úÖ Kubeconfig syntax is valid"
          
          # Show cluster info for debugging
          echo "üìã Kubeconfig details:"
          echo "Current context: $(kubectl config current-context 2>/dev/null || echo 'None')"
          echo "Available contexts:"
          kubectl config get-contexts --no-headers 2>/dev/null || echo "No contexts found"
          
          # Test cluster connectivity
          echo "üîó Testing cluster connectivity..."
          if timeout 45 kubectl cluster-info --request-timeout=30s > /dev/null 2>&1; then
            echo "‚úÖ Successfully connected to Kubernetes cluster!"
            kubectl cluster-info --request-timeout=30s
            echo ""
            echo "üéØ Cluster version info:"
            kubectl version --short 2>/dev/null || kubectl version --client
          else
            echo "‚ùå Failed to connect to Kubernetes cluster!"
            echo ""
            echo "üîç Debugging information:"
            echo "1. Current context: $(kubectl config current-context 2>/dev/null || echo 'No context set')"
            echo "2. Server URL: $(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}' 2>/dev/null || echo 'Unknown')"
            echo ""
            echo "üö® Possible causes:"
            echo "- Cluster is down or unreachable"
            echo "- Kubeconfig authentication tokens have expired"
            echo "- Network connectivity issues"
            echo "- Cluster credentials need to be refreshed"
            echo ""
            echo "üí° Solutions:"
            echo "- For EKS: aws eks update-kubeconfig --region <region> --name <cluster>"
            echo "- For GKE: gcloud container clusters get-credentials <cluster> --zone <zone>"
            echo "- For AKS: az aks get-credentials --resource-group <rg> --name <cluster>"
            echo "- Then re-encode: cat ~/.kube/config | base64 -w 0"
            exit 1
          fi
        env:
          KUBECONFIG: kubeconfig

      - name: Set deployment parameters
        id: params
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            RESOURCE_TYPE="${{ github.event.inputs.resource_type }}"
          else
            ENVIRONMENT="staging"  # Auto-deploy to staging for pushes
            RESOURCE_TYPE="all"
          fi
          
          # Use your actual namespaces
          if [ "$ENVIRONMENT" = "production" ]; then
            NAMESPACE="bedrock-chat-v2"
          else
            NAMESPACE="bedrock-chat-staging"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
          echo "resource_type=$RESOURCE_TYPE" >> $GITHUB_OUTPUT
          
          echo "üöÄ Infrastructure Deployment:"
          echo "- Environment: $ENVIRONMENT"
          echo "- Namespace: $NAMESPACE"
          echo "- Resource Type: $RESOURCE_TYPE"

      - name: Create namespace
        run: |
          export KUBECONFIG=kubeconfig
          kubectl create namespace ${{ steps.params.outputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -
          kubectl label namespace ${{ steps.params.outputs.namespace }} name=${{ steps.params.outputs.namespace }} --overwrite

      - name: Apply ConfigMaps
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'configmaps'
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üìã Applying ConfigMaps..."
          kubectl apply -f k8s/configmaps/app-config.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/configmaps/mysql-init.yaml -n ${{ steps.params.outputs.namespace }}
          
          echo "‚úÖ ConfigMaps applied:"
          kubectl get configmaps -n ${{ steps.params.outputs.namespace }}

      - name: Apply Secrets
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'secrets'
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üîê Applying Secrets..."
          kubectl apply -f k8s/secrets/app-secrets.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/secrets/mysql-secrets.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/dockerhub-secrets.yaml -n ${{ steps.params.outputs.namespace }}
          
          echo "‚úÖ Secrets applied:"
          kubectl get secrets -n ${{ steps.params.outputs.namespace }}

      - name: Apply PVCs
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'statefulsets'
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üíæ Applying PVCs..."
          kubectl apply -f k8s/pvc/file-uploads-pvc.yaml -n ${{ steps.params.outputs.namespace }}
          
          echo "‚úÖ PVCs applied:"
          kubectl get pvc -n ${{ steps.params.outputs.namespace }}

      - name: Deploy MySQL StatefulSet
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'statefulsets' || steps.params.outputs.resource_type == 'mysql-only'
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üóÑÔ∏è Deploying MySQL StatefulSet..."
          kubectl apply -f k8s/services/mysql-service.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/services/mysql-headless-service.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/statefulsets/mysql-statefulset.yaml -n ${{ steps.params.outputs.namespace }}
          
          echo "‚è≥ Waiting for MySQL to be ready..."
          kubectl rollout status statefulset/mysql -n ${{ steps.params.outputs.namespace }} --timeout=300s || {
            echo "‚ö†Ô∏è MySQL rollout timeout, checking status..."
            kubectl get pods -l app=mysql -n ${{ steps.params.outputs.namespace }}
            kubectl describe statefulset mysql -n ${{ steps.params.outputs.namespace }}
          }

      - name: Apply Services
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'services'
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üåê Applying Microservice Services..."
          kubectl apply -f k8s/services/api-gateway-service.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/services/bedrock-service-service.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/services/file-service-service.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/services/frontend-service.yaml -n ${{ steps.params.outputs.namespace }}
          
          # Apply NodePort service if exists
          if [ -f "k8s/services/frontend-nodeport.yaml" ]; then
            kubectl apply -f k8s/services/frontend-nodeport.yaml -n ${{ steps.params.outputs.namespace }}
          fi
          
          echo "‚úÖ Services applied:"
          kubectl get services -n ${{ steps.params.outputs.namespace }}

      - name: Apply Ingress (Production Only)
        if: (steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'ingress') && steps.params.outputs.environment == 'production'
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üåç Applying Ingress for Production..."
          kubectl apply -f k8s/ingress/bedrock-chat-ingress.yaml -n ${{ steps.params.outputs.namespace }}
          
          echo "‚úÖ Ingress applied:"
          kubectl get ingress -n ${{ steps.params.outputs.namespace }}
          kubectl describe ingress bedrock-chat-ingress -n ${{ steps.params.outputs.namespace }}

      - name: Apply Network Policies
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'network-policies'
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üîí Applying Network Policies..."
          kubectl apply -f k8s/network-policies/ -n ${{ steps.params.outputs.namespace }}
          
          echo "‚úÖ Network Policies applied:"
          kubectl get networkpolicies -n ${{ steps.params.outputs.namespace }}

      - name: Apply HPA
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'hpa'
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üìà Applying HPA..."
          if kubectl get apiservice v1beta1.metrics.k8s.io > /dev/null 2>&1; then
            kubectl apply -f k8s/hpa/ -n ${{ steps.params.outputs.namespace }}
            echo "‚úÖ HPA applied:"
            kubectl get hpa -n ${{ steps.params.outputs.namespace }}
          else
            echo "‚ö†Ô∏è Metrics server not available, skipping HPA"
            # Try to install/fix metrics server
            echo "üîß Applying custom metrics server..."
            kubectl apply -f k8s/metrics-server-custom.yaml || echo "Metrics server apply failed"
          fi

      - name: Verify Infrastructure
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üîç Verifying infrastructure deployment..."
          
          echo "=== Namespace ==="
          kubectl get namespace ${{ steps.params.outputs.namespace }}
          
          echo "=== ConfigMaps ==="
          kubectl get configmaps -n ${{ steps.params.outputs.namespace }}
          
          echo "=== Secrets ==="
          kubectl get secrets -n ${{ steps.params.outputs.namespace }}
          
          echo "=== PVCs ==="
          kubectl get pvc -n ${{ steps.params.outputs.namespace }}
          
          echo "=== StatefulSets ==="
          kubectl get statefulsets -n ${{ steps.params.outputs.namespace }}
          
          echo "=== Services ==="
          kubectl get services -n ${{ steps.params.outputs.namespace }}
          
          if [ "${{ steps.params.outputs.environment }}" = "production" ]; then
            echo "=== Ingress ==="
            kubectl get ingress -n ${{ steps.params.outputs.namespace }}
          fi
          
          echo "=== Network Policies ==="
          kubectl get networkpolicies -n ${{ steps.params.outputs.namespace }} || echo "No Network Policies"
          
          echo "=== HPA ==="
          kubectl get hpa -n ${{ steps.params.outputs.namespace }} || echo "No HPA"

      - name: Run Infrastructure Health Checks
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üè• Running infrastructure health checks..."
          
          # Check MySQL if deployed
          if kubectl get statefulset mysql -n ${{ steps.params.outputs.namespace }} > /dev/null 2>&1; then
            echo "Checking MySQL health..."
            if kubectl wait --for=condition=ready pod -l app=mysql -n ${{ steps.params.outputs.namespace }} --timeout=60s; then
              echo "‚úÖ MySQL is healthy"
            else
              echo "‚ö†Ô∏è MySQL health check failed"
              kubectl logs -l app=mysql -n ${{ steps.params.outputs.namespace }} --tail=10
            fi
          fi
          
          # Check services
          echo "Checking services..."
          kubectl get endpoints -n ${{ steps.params.outputs.namespace }}

      - name: Deployment summary
        if: always()
        run: |
          echo "## üèóÔ∏è Infrastructure Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ steps.params.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: ${{ steps.params.outputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Resource Type**: ${{ steps.params.outputs.resource_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ **Infrastructure deployment completed successfully!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üìä Deployed Resources" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            export KUBECONFIG=kubeconfig
            kubectl get all -n ${{ steps.params.outputs.namespace }} >> $GITHUB_STEP_SUMMARY 2>&1 || true
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Infrastructure deployment failed!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üîç Troubleshooting" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            export KUBECONFIG=kubeconfig
            kubectl get events -n ${{ steps.params.outputs.namespace }} --sort-by='.lastTimestamp' | tail -15 >> $GITHUB_STEP_SUMMARY 2>&1 || true
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi
