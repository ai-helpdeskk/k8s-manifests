# .github/workflows/cd.yml
name: CD - Deploy to Kubernetes

on:
  repository_dispatch:
    types: 
      - deploy-api-gateway
      - deploy-bedrock-service
      - deploy-file-service
      - deploy-frontend
      - deploy-all
  push:
    branches: [ main ]
    paths:
      - 'k8s/**'
      - '!README.md'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      service:
        description: 'Service to deploy'
        required: true
        default: 'all'
        type: choice
        options:
        - all
        - api-gateway
        - bedrock-service
        - file-service
        - frontend
        - infrastructure-only

env:
  KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
        
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
        
    - name: Configure kubectl
      run: |
        if [ -z "${{ env.KUBE_CONFIG_DATA }}" ]; then
          echo "‚ùå KUBE_CONFIG_DATA secret not found!"
          echo "Please set the KUBE_CONFIG_DATA secret with base64 encoded kubeconfig"
          exit 1
        fi
        
        echo "${{ env.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
        
        # Test kubectl connection
        if ! kubectl cluster-info > /dev/null 2>&1; then
          echo "‚ùå Failed to connect to Kubernetes cluster"
          exit 1
        fi
        
        echo "‚úÖ Successfully connected to Kubernetes cluster"
        kubectl cluster-info
        
    - name: Determine deployment parameters
      id: params
      run: |
        # Set environment and service from different trigger types
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          ENV="${{ github.event.inputs.environment }}"
          SERVICE="${{ github.event.inputs.service }}"
        elif [ "${{ github.event_name }}" = "repository_dispatch" ]; then
          ENV="${{ github.event.client_payload.environment }}"
          SERVICE_TYPE="${{ github.event.action }}"
          # Extract service name from event type (deploy-api-gateway -> api-gateway)
          SERVICE=$(echo "${SERVICE_TYPE}" | sed 's/deploy-//')
        else
          ENV="staging"
          SERVICE="all"
        fi
        
        # Set namespace based on environment
        if [ "$ENV" = "production" ]; then
          NAMESPACE="bedrock-chat-v2"
        else
          NAMESPACE="bedrock-chat-staging"
        fi
        
        echo "environment=$ENV" >> $GITHUB_OUTPUT
        echo "service=$SERVICE" >> $GITHUB_OUTPUT
        echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
        
        echo "üöÄ Deployment Parameters:"
        echo "- Environment: $ENV"
        echo "- Service: $SERVICE"
        echo "- Namespace: $NAMESPACE"
        
    - name: Create namespace and setup infrastructure
      run: |
        export KUBECONFIG=kubeconfig
        
        echo "üìù Creating namespace: ${{ steps.params.outputs.namespace }}"
        kubectl create namespace ${{ steps.params.outputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -
        
        echo "üîß Applying infrastructure components..."
        
        # Apply ConfigMaps
        if [ -d "k8s/configmaps" ]; then
          echo "üìã Applying ConfigMaps..."
          kubectl apply -f k8s/configmaps/ -n ${{ steps.params.outputs.namespace }} || true
        fi
        
        # Apply Secrets (if they exist)
        if [ -d "k8s/secrets" ]; then
          echo "üîê Applying Secrets..."
          # Only apply if files exist and are not empty
          for secret_file in k8s/secrets/*.yaml; do
            if [ -f "$secret_file" ]; then
              echo "Applying $secret_file"
              kubectl apply -f "$secret_file" -n ${{ steps.params.outputs.namespace }} || echo "‚ö†Ô∏è Warning: Failed to apply $secret_file"
            fi
          done
        fi
        
        # Apply PVCs
        if [ -d "k8s/pvc" ]; then
          echo "üíæ Applying PVCs..."
          kubectl apply -f k8s/pvc/ -n ${{ steps.params.outputs.namespace }} || true
        fi
        
        # Apply Services
        if [ -d "k8s/services" ]; then
          echo "üåê Applying Services..."
          kubectl apply -f k8s/services/ -n ${{ steps.params.outputs.namespace }} || true
        fi
        
    - name: Deploy StatefulSets (Database)
      run: |
        export KUBECONFIG=kubeconfig
        
        if [ -d "k8s/statefulsets" ] && [ "${{ steps.params.outputs.service }}" = "all" ]; then
          echo "üóÑÔ∏è Deploying StatefulSets (Database)..."
          kubectl apply -f k8s/statefulsets/ -n ${{ steps.params.outputs.namespace }}
          
          # Wait for MySQL to be ready
          echo "‚è≥ Waiting for MySQL to be ready..."
          kubectl wait --for=condition=ready pod -l app=mysql -n ${{ steps.params.outputs.namespace }} --timeout=300s || {
            echo "‚ö†Ô∏è MySQL not ready within timeout, continuing anyway..."
          }
        fi
        
    - name: Deploy specific service
      if: steps.params.outputs.service != 'all' && steps.params.outputs.service != 'infrastructure-only'
      run: |
        export KUBECONFIG=kubeconfig
        
        SERVICE_NAME="${{ steps.params.outputs.service }}"
        DEPLOYMENT_FILE="k8s/deployments/${SERVICE_NAME}-deployment.yaml"
        
        echo "üöÄ Deploying specific service: $SERVICE_NAME"
        
        if [ -f "$DEPLOYMENT_FILE" ]; then
          echo "üì¶ Applying $DEPLOYMENT_FILE"
          kubectl apply -f $DEPLOYMENT_FILE -n ${{ steps.params.outputs.namespace }}
          
          echo "‚è≥ Waiting for $SERVICE_NAME rollout..."
          kubectl rollout status deployment/$SERVICE_NAME -n ${{ steps.params.outputs.namespace }} --timeout=300s
          
          echo "‚úÖ $SERVICE_NAME deployed successfully"
        else
          echo "‚ùå Deployment file not found: $DEPLOYMENT_FILE"
          echo "Available deployment files:"
          ls -la k8s/deployments/ || echo "No deployments directory found"
          exit 1
        fi
        
    - name: Deploy all services
      if: steps.params.outputs.service == 'all'
      run: |
        export KUBECONFIG=kubeconfig
        
        echo "üöÄ Deploying all services..."
        
        # Deploy all deployments
        if [ -d "k8s/deployments" ]; then
          kubectl apply -f k8s/deployments/ -n ${{ steps.params.outputs.namespace }}
          
          echo "‚è≥ Waiting for all deployments to be ready..."
          
          # Wait for deployments individually with better error handling
          DEPLOYMENTS=("bedrock-service" "file-service" "api-gateway" "frontend")
          
          for deployment in "${DEPLOYMENTS[@]}"; do
            echo "‚è≥ Waiting for $deployment..."
            if kubectl get deployment $deployment -n ${{ steps.params.outputs.namespace }} > /dev/null 2>&1; then
              kubectl rollout status deployment/$deployment -n ${{ steps.params.outputs.namespace }} --timeout=300s || {
                echo "‚ö†Ô∏è Warning: $deployment rollout timeout, but continuing..."
              }
            else
              echo "‚ÑπÔ∏è Deployment $deployment not found, skipping..."
            fi
          done
        fi
        
    - name: Deploy Ingress
      if: steps.params.outputs.service == 'all' || steps.params.outputs.service == 'infrastructure-only'
      run: |
        export KUBECONFIG=kubeconfig
        
        if [ -d "k8s/ingress" ]; then
          echo "üåç Applying Ingress configurations..."
          kubectl apply -f k8s/ingress/ -n ${{ steps.params.outputs.namespace }} || {
            echo "‚ö†Ô∏è Warning: Ingress application failed, but continuing..."
          }
        fi
        
    - name: Apply Network Policies
      if: steps.params.outputs.service == 'all' || steps.params.outputs.service == 'infrastructure-only'
      run: |
        export KUBECONFIG=kubeconfig
        
        if [ -d "k8s/network-policies" ]; then
          echo "üîí Applying Network Policies..."
          kubectl apply -f k8s/network-policies/ -n ${{ steps.params.outputs.namespace }} || {
            echo "‚ö†Ô∏è Warning: Network policies application failed, but continuing..."
          }
        fi
        
    - name: Apply HPA (if enabled)
      if: steps.params.outputs.service == 'all' || steps.params.outputs.service == 'infrastructure-only'
      run: |
        export KUBECONFIG=kubeconfig
        
        if [ -d "k8s/hpa" ]; then
          echo "üìà Applying Horizontal Pod Autoscalers..."
          kubectl apply -f k8s/hpa/ -n ${{ steps.params.outputs.namespace }} || {
            echo "‚ö†Ô∏è Warning: HPA application failed (metrics-server might not be available)"
          }
        fi
        
    - name: Verify deployment
      run: |
        export KUBECONFIG=kubeconfig
        
        echo "üîç Verifying deployment status..."
        
        echo "=== Namespace ==="
        kubectl get namespace ${{ steps.params.outputs.namespace }}
        
        echo "=== Pods ==="
        kubectl get pods -n ${{ steps.params.outputs.namespace }} -o wide
        
        echo "=== Services ==="
        kubectl get svc -n ${{ steps.params.outputs.namespace }}
        
        echo "=== Deployments ==="
        kubectl get deployments -n ${{ steps.params.outputs.namespace }}
        
        echo "=== StatefulSets ==="
        kubectl get statefulsets -n ${{ steps.params.outputs.namespace }} || echo "No StatefulSets found"
        
        echo "=== Ingress ==="
        kubectl get ingress -n ${{ steps.params.outputs.namespace }} || echo "No Ingress found"
        
        echo "=== PVCs ==="
        kubectl get pvc -n ${{ steps.params.outputs.namespace }} || echo "No PVCs found"
        
    - name: Run health checks
      run: |
        export KUBECONFIG=kubeconfig
        
        echo "üè• Running health checks..."
        
        # Wait a bit for services to be fully ready
        sleep 30
        
        # Function to check service health
        check_service_health() {
          local service_name=$1
          local port=$2
          local health_path=$3
          
          echo "Checking $service_name health..."
          
          if kubectl get deployment $service_name -n ${{ steps.params.outputs.namespace }} > /dev/null 2>&1; then
            # Check if pods are running
            if kubectl get pods -l app=$service_name -n ${{ steps.params.outputs.namespace }} | grep -q Running; then
              # Try health check
              kubectl exec -n ${{ steps.params.outputs.namespace }} deployment/$service_name -- wget -qO- --timeout=10 http://localhost:$port$health_path > /dev/null 2>&1 && {
                echo "‚úÖ $service_name is healthy"
                return 0
              } || {
                echo "‚ö†Ô∏è $service_name health check failed, but pod is running"
                return 1
              }
            else
              echo "‚ùå $service_name pods are not running"
              return 1
            fi
          else
            echo "‚ÑπÔ∏è $service_name deployment not found, skipping health check"
            return 0
          fi
        }
        
        # Check individual services
        HEALTH_FAILURES=0
        
        check_service_health "api-gateway" "8000" "/health" || ((HEALTH_FAILURES++))
        check_service_health "bedrock-service" "9000" "/health" || ((HEALTH_FAILURES++))
        check_service_health "file-service" "7000" "/health" || ((HEALTH_FAILURES++))
        check_service_health "frontend" "3000" "/health" || ((HEALTH_FAILURES++))
        
        if [ $HEALTH_FAILURES -eq 0 ]; then
          echo "‚úÖ All health checks passed!"
        else
          echo "‚ö†Ô∏è $HEALTH_FAILURES health check(s) failed, but deployment completed"
        fi
        
    - name: Deployment summary
      if: always()
      run: |
        echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment**: ${{ steps.params.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Namespace**: ${{ steps.params.outputs.namespace }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Service**: ${{ steps.params.outputs.service }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ job.status }}" = "success" ]; then
          echo "‚úÖ **Deployment completed successfully!**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîó Access Information" >> $GITHUB_STEP_SUMMARY
          echo "- Check ingress configuration for external access" >> $GITHUB_STEP_SUMMARY
          echo "- Use \`kubectl get ingress -n ${{ steps.params.outputs.namespace }}\` to see endpoints" >> $GITHUB_STEP_SUMMARY
        else
          echo "‚ùå **Deployment failed!**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîç Troubleshooting" >> $GITHUB_STEP_SUMMARY
          echo "- Check the workflow logs above for error details" >> $GITHUB_STEP_SUMMARY
          echo "- Verify secrets are properly configured" >> $GITHUB_STEP_SUMMARY
          echo "- Ensure Kubernetes cluster is accessible" >> $GITHUB_STEP_SUMMARY
        fi
