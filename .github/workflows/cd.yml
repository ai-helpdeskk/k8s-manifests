# .github/workflows/deploy-k8s-infrastructure.yml
name: Deploy K8s Infrastructure Changes

on:
  push:
    branches: [ main ]
    paths:
      - 'k8s/configmaps/**'
      - 'k8s/services/**'
      - 'k8s/ingress/**'
      - 'k8s/pvc/**'
      - 'k8s/secrets/**'
      - 'k8s/network-policies/**'
      - 'k8s/hpa/**'
      - 'k8s/statefulsets/**'
      # Exclude deployment files - handled by service CDs
      - '!k8s/deployments/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      resource_type:
        description: 'Type of resource to deploy'
        required: true
        default: 'all'
        type: choice
        options:
        - all
        - configmaps
        - services
        - ingress
        - secrets
        - network-policies
        - hpa
        - statefulsets
        - mysql-only

jobs:
  deploy-infrastructure:
    name: Deploy Infrastructure Changes
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout k8s manifests
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl for EC2
        run: |
          echo "🔍 Checking KUBE_CONFIG_DATA secret..."
          
          # Check if secret exists and has content
          if [ -z "${{ secrets.KUBE_CONFIG_DATA }}" ]; then
            echo "❌ KUBE_CONFIG_DATA secret is empty or not set!"
            echo ""
            echo "🔧 To fix this issue for EC2:"
            echo "1. SSH into your EC2 instance"
            echo "2. Run: cat ~/.kube/config | base64 -w 0"
            echo "3. Copy the output and add it as KUBE_CONFIG_DATA secret in GitHub"
            echo "4. Make sure to copy the ENTIRE base64 string (it should be very long)"
            echo ""
            echo "💡 If you don't have kubectl configured on EC2:"
            echo "- For minikube: minikube start && cat ~/.kube/config | base64 -w 0"
            echo "- For k3s: sudo cat /etc/rancher/k3s/k3s.yaml | base64 -w 0"
            echo "- For kubeadm: cat ~/.kube/config | base64 -w 0"
            exit 1
          fi
          
          echo "✅ KUBE_CONFIG_DATA secret found"
          
          # Create .kube directory
          mkdir -p ~/.kube
          
          # Decode the kubeconfig
          echo "🔧 Decoding kubeconfig..."
          echo "${{ secrets.KUBE_CONFIG_DATA }}" | base64 -d > ~/.kube/config
          
          # Check if decoded file has content
          if [ ! -s ~/.kube/config ]; then
            echo "❌ Decoded kubeconfig file is empty!"
            echo "This usually means the base64 encoding was corrupted."
            echo ""
            echo "🔧 Please re-create the secret:"
            echo "1. On your EC2: cat ~/.kube/config | base64 -w 0 | tr -d '\n'"
            echo "2. Copy the ENTIRE output (should be one long line)"
            echo "3. Update KUBE_CONFIG_DATA secret in GitHub"
            exit 1
          fi
          
          # Set permissions
          chmod 600 ~/.kube/config
          
          echo "✅ Kubeconfig file created and configured"
          
          # Validate kubeconfig syntax
          echo "🔍 Validating kubeconfig syntax..."
          if ! kubectl config view > /dev/null 2>&1; then
            echo "❌ Invalid kubeconfig format!"
            echo "The kubeconfig file has syntax errors."
            echo "Please check your original kubeconfig file and re-encode it."
            exit 1
          fi
          
          echo "✅ Kubeconfig syntax is valid"
          
          # Show cluster info for debugging
          echo "📋 Kubeconfig details:"
          echo "Current context: $(kubectl config current-context 2>/dev/null || echo 'None')"
          echo "Available contexts:"
          kubectl config get-contexts --no-headers 2>/dev/null || echo "No contexts found"
          
          # Test cluster connectivity with longer timeout for EC2
          echo "🔗 Testing cluster connectivity..."
          if timeout 60 kubectl cluster-info --request-timeout=45s > /dev/null 2>&1; then
            echo "✅ Successfully connected to Kubernetes cluster!"
            kubectl cluster-info --request-timeout=45s
            echo ""
            echo "🎯 Cluster version info:"
            kubectl version --short 2>/dev/null || kubectl version --client
          else
            echo "❌ Failed to connect to Kubernetes cluster!"
            echo ""
            echo "🔍 Debugging information:"
            echo "1. Current context: $(kubectl config current-context 2>/dev/null || echo 'No context set')"
            echo "2. Server URL: $(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}' 2>/dev/null || echo 'Unknown')"
            echo ""
            echo "🚨 Possible causes for EC2:"
            echo "- EC2 instance or Kubernetes cluster is down"
            echo "- Security groups blocking access"
            echo "- Kubeconfig server URL might be localhost/127.0.0.1 (needs to be EC2 internal IP)"
            echo "- Network connectivity issues between GitHub Actions and EC2"
            echo ""
            echo "💡 Solutions for different setups:"
            echo "- For minikube: Ensure minikube is running and accessible"
            echo "- For k3s: Check if k3s service is running: sudo systemctl status k3s"
            echo "- For kubeadm: Verify all control plane components are healthy"
            echo "- Check EC2 security groups allow access on Kubernetes API port (usually 6443)"
            echo ""
            echo "🔧 To fix kubeconfig server URL:"
            echo "Edit ~/.kube/config and replace 127.0.0.1 with your EC2 private IP"
            exit 1
          fi

      - name: Set deployment parameters
        id: params
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            RESOURCE_TYPE="${{ github.event.inputs.resource_type }}"
          else
            ENVIRONMENT="staging"  # Auto-deploy to staging for pushes
            RESOURCE_TYPE="all"
          fi
          
          # Use your actual namespaces
          if [ "$ENVIRONMENT" = "production" ]; then
            NAMESPACE="bedrock-chat-v2"
          else
            NAMESPACE="bedrock-chat-staging"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
          echo "resource_type=$RESOURCE_TYPE" >> $GITHUB_OUTPUT
          
          echo "🚀 Infrastructure Deployment:"
          echo "- Environment: $ENVIRONMENT"
          echo "- Namespace: $NAMESPACE"
          echo "- Resource Type: $RESOURCE_TYPE"

      - name: Create namespace
        run: |
          kubectl create namespace ${{ steps.params.outputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -
          kubectl label namespace ${{ steps.params.outputs.namespace }} name=${{ steps.params.outputs.namespace }} --overwrite

      - name: Apply ConfigMaps
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'configmaps'
        run: |
          echo "📋 Applying ConfigMaps..."
          kubectl apply -f k8s/configmaps/app-config.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/configmaps/mysql-init.yaml -n ${{ steps.params.outputs.namespace }}
          
          echo "✅ ConfigMaps applied:"
          kubectl get configmaps -n ${{ steps.params.outputs.namespace }}

      - name: Apply Secrets
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'secrets'
        run: |
          echo "🔐 Applying Secrets..."
          kubectl apply -f k8s/secrets/app-secrets.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/secrets/mysql-secrets.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/dockerhub-secrets.yaml -n ${{ steps.params.outputs.namespace }}
          
          echo "✅ Secrets applied:"
          kubectl get secrets -n ${{ steps.params.outputs.namespace }}

      - name: Apply PVCs
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'statefulsets'
        run: |
          echo "💾 Applying PVCs..."
          kubectl apply -f k8s/pvc/file-uploads-pvc.yaml -n ${{ steps.params.outputs.namespace }}
          
          echo "✅ PVCs applied:"
          kubectl get pvc -n ${{ steps.params.outputs.namespace }}

      - name: Deploy MySQL StatefulSet
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'statefulsets' || steps.params.outputs.resource_type == 'mysql-only'
        run: |
          echo "🗄️ Deploying MySQL StatefulSet..."
          kubectl apply -f k8s/services/mysql-service.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/services/mysql-headless-service.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/statefulsets/mysql-statefulset.yaml -n ${{ steps.params.outputs.namespace }}
          
          echo "⏳ Waiting for MySQL to be ready..."
          kubectl rollout status statefulset/mysql -n ${{ steps.params.outputs.namespace }} --timeout=600s || {
            echo "⚠️ MySQL rollout timeout, checking status..."
            kubectl get pods -l app=mysql -n ${{ steps.params.outputs.namespace }}
            kubectl describe statefulset mysql -n ${{ steps.params.outputs.namespace }}
            kubectl logs -l app=mysql -n ${{ steps.params.outputs.namespace }} --tail=20 || echo "No logs available"
          }

      - name: Apply Services
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'services'
        run: |
          echo "🌐 Applying Microservice Services..."
          kubectl apply -f k8s/services/api-gateway-service.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/services/bedrock-service-service.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/services/file-service-service.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/services/frontend-service.yaml -n ${{ steps.params.outputs.namespace }}
          
          # Apply NodePort service if exists
          if [ -f "k8s/services/frontend-nodeport.yaml" ]; then
            kubectl apply -f k8s/services/frontend-nodeport.yaml -n ${{ steps.params.outputs.namespace }}
          fi
          
          echo "✅ Services applied:"
          kubectl get services -n ${{ steps.params.outputs.namespace }}

      - name: Apply Ingress (Production Only)
        if: (steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'ingress') && steps.params.outputs.environment == 'production'
        run: |
          echo "🌍 Applying Ingress for Production..."
          if [ -f "k8s/ingress/bedrock-chat-ingress.yaml" ]; then
            kubectl apply -f k8s/ingress/bedrock-chat-ingress.yaml -n ${{ steps.params.outputs.namespace }}
            
            echo "✅ Ingress applied:"
            kubectl get ingress -n ${{ steps.params.outputs.namespace }}
            kubectl describe ingress bedrock-chat-ingress -n ${{ steps.params.outputs.namespace }}
          else
            echo "⚠️ Ingress file not found, skipping..."
          fi

      - name: Apply Network Policies
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'network-policies'
        run: |
          echo "🔒 Applying Network Policies..."
          if [ -d "k8s/network-policies" ]; then
            kubectl apply -f k8s/network-policies/ -n ${{ steps.params.outputs.namespace }}
            
            echo "✅ Network Policies applied:"
            kubectl get networkpolicies -n ${{ steps.params.outputs.namespace }}
          else
            echo "⚠️ Network policies directory not found, skipping..."
          fi

      - name: Apply HPA
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'hpa'
        run: |
          echo "📈 Applying HPA..."
          if kubectl get apiservice v1beta1.metrics.k8s.io > /dev/null 2>&1; then
            if [ -d "k8s/hpa" ]; then
              kubectl apply -f k8s/hpa/ -n ${{ steps.params.outputs.namespace }}
              echo "✅ HPA applied:"
              kubectl get hpa -n ${{ steps.params.outputs.namespace }}
            else
              echo "⚠️ HPA directory not found"
            fi
          else
            echo "⚠️ Metrics server not available, skipping HPA"
            # Try to install/fix metrics server
            echo "🔧 Applying custom metrics server..."
            if [ -f "k8s/metrics-server-custom.yaml" ]; then
              kubectl apply -f k8s/metrics-server-custom.yaml || echo "Metrics server apply failed"
            fi
          fi

      - name: Verify Infrastructure
        run: |
          echo "🔍 Verifying infrastructure deployment..."
          
          echo "=== Namespace ==="
          kubectl get namespace ${{ steps.params.outputs.namespace }}
          
          echo "=== ConfigMaps ==="
          kubectl get configmaps -n ${{ steps.params.outputs.namespace }}
          
          echo "=== Secrets ==="
          kubectl get secrets -n ${{ steps.params.outputs.namespace }}
          
          echo "=== PVCs ==="
          kubectl get pvc -n ${{ steps.params.outputs.namespace }}
          
          echo "=== StatefulSets ==="
          kubectl get statefulsets -n ${{ steps.params.outputs.namespace }}
          
          echo "=== Services ==="
          kubectl get services -n ${{ steps.params.outputs.namespace }}
          
          if [ "${{ steps.params.outputs.environment }}" = "production" ]; then
            echo "=== Ingress ==="
            kubectl get ingress -n ${{ steps.params.outputs.namespace }} || echo "No ingress found"
          fi
          
          echo "=== Network Policies ==="
          kubectl get networkpolicies -n ${{ steps.params.outputs.namespace }} || echo "No Network Policies"
          
          echo "=== HPA ==="
          kubectl get hpa -n ${{ steps.params.outputs.namespace }} || echo "No HPA"
          
          echo "=== All Pods ==="
          kubectl get pods -n ${{ steps.params.outputs.namespace }} -o wide

      - name: Run Infrastructure Health Checks
        run: |
          echo "🏥 Running infrastructure health checks..."
          
          # Check MySQL if deployed
          if kubectl get statefulset mysql -n ${{ steps.params.outputs.namespace }} > /dev/null 2>&1; then
            echo "Checking MySQL health..."
            if kubectl wait --for=condition=ready pod -l app=mysql -n ${{ steps.params.outputs.namespace }} --timeout=120s; then
              echo "✅ MySQL is healthy"
            else
              echo "⚠️ MySQL health check failed"
              kubectl logs -l app=mysql -n ${{ steps.params.outputs.namespace }} --tail=20 || echo "No MySQL logs available"
            fi
          fi
          
          # Check services
          echo "Checking services..."
          kubectl get endpoints -n ${{ steps.params.outputs.namespace }}

      - name: Deployment summary
        if: always()
        run: |
          echo "## 🏗️ Infrastructure Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ steps.params.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: ${{ steps.params.outputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Resource Type**: ${{ steps.params.outputs.resource_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" = "success" ]; then
            echo "✅ **Infrastructure deployment completed successfully!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### 📊 Deployed Resources" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            kubectl get all -n ${{ steps.params.outputs.namespace }} >> $GITHUB_STEP_SUMMARY 2>&1 || true
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Infrastructure deployment failed!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### 🔍 Troubleshooting" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            kubectl get events -n ${{ steps.params.outputs.namespace }} --sort-by='.lastTimestamp' | tail -15 >> $GITHUB_STEP_SUMMARY 2>&1 || true
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi
