# .github/workflows/deploy-k8s-infrastructure.yml
name: Deploy K8s Infrastructure Changes

on:
  push:
    branches: [ main ]
    paths:
      - 'k8s/configmaps/**'
      - 'k8s/services/**'
      - 'k8s/ingress/**'
      - 'k8s/pvc/**'
      - 'k8s/secrets/**'
      - 'k8s/network-policies/**'
      - 'k8s/hpa/**'
      - 'k8s/statefulsets/**'
      # Exclude deployment files - handled by service CDs
      - '!k8s/deployments/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      resource_type:
        description: 'Type of resource to deploy'
        required: true
        default: 'all'
        type: choice
        options:
        - all
        - configmaps
        - services
        - ingress
        - secrets
        - network-policies
        - hpa
        - statefulsets
        - mysql-only

jobs:
  deploy-infrastructure:
    name: Deploy Infrastructure Changes
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout k8s manifests
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl for EC2
        run: |
          echo "ðŸ” Checking KUBE_CONFIG_DATA secret..."
          
          # Check if secret exists and has content
          if [ -z "${{ secrets.KUBE_CONFIG_DATA }}" ]; then
            echo "âŒ KUBE_CONFIG_DATA secret is empty or not set!"
            echo ""
            echo "ðŸ”§ To fix this issue for EC2:"
            echo "1. SSH into your EC2 instance"
            echo "2. Run: cat ~/.kube/config | base64 -w 0"
            echo "3. Copy the output and add it as KUBE_CONFIG_DATA secret in GitHub"
            echo "4. Make sure to copy the ENTIRE base64 string (it should be very long)"
            echo ""
            echo "ðŸ’¡ If you don't have kubectl configured on EC2:"
            echo "- For minikube: minikube start && cat ~/.kube/config | base64 -w 0"
            echo "- For k3s: sudo cat /etc/rancher/k3s/k3s.yaml | base64 -w 0"
            echo "- For kubeadm: cat ~/.kube/config | base64 -w 0"
            exit 1
          fi
          
          echo "âœ… KUBE_CONFIG_DATA secret found"
          
          # Create .kube directory
          mkdir -p ~/.kube
          
          # Decode the kubeconfig
          echo "ðŸ”§ Decoding kubeconfig..."
          echo "${{ secrets.KUBE_CONFIG_DATA }}" | base64 -d > ~/.kube/config
          
          # Check if decoded file has content
          if [ ! -s ~/.kube/config ]; then
            echo "âŒ Decoded kubeconfig file is empty!"
            echo "This usually means the base64 encoding was corrupted."
            echo ""
            echo "ðŸ”§ Please re-create the secret:"
            echo "1. On your EC2: cat ~/.kube/config | base64 -w 0 | tr -d '\n'"
            echo "2. Copy the ENTIRE output (should be one long line)"
            echo "3. Update KUBE_CONFIG_DATA secret in GitHub"
            exit 1
          fi
          
          # Set permissions
          chmod 600 ~/.kube/config
          
          echo "âœ… Kubeconfig file created and configured"
          
          # Validate kubeconfig syntax
          echo "ðŸ” Validating kubeconfig syntax..."
          if ! kubectl config view > /dev/null 2>&1; then
            echo "âŒ Invalid kubeconfig format!"
            echo "The kubeconfig file has syntax errors."
            echo "Please check your original kubeconfig file and re-encode it."
            exit 1
          fi
          
          echo "âœ… Kubeconfig syntax is valid"
          
          # Show cluster info for debugging
          echo "ðŸ“‹ Kubeconfig details:"
          echo "Current context: $(kubectl config current-context 2>/dev/null || echo 'None')"
          echo "Available contexts:"
          kubectl config get-contexts --no-headers 2>/dev/null || echo "No contexts found"
          
          # Test cluster connectivity with longer timeout for EC2
          echo "ðŸ”— Testing cluster connectivity..."
          if timeout 60 kubectl cluster-info --request-timeout=45s > /dev/null 2>&1; then
            echo "âœ… Successfully connected to Kubernetes cluster!"
            kubectl cluster-info --request-timeout=45s
            echo ""
            echo "ðŸŽ¯ Cluster version info:"
            kubectl version --short 2>/dev/null || kubectl version --client
          else
            echo "âŒ Failed to connect to Kubernetes cluster!"
            echo ""
            echo "ðŸ” Debugging information:"
            echo "1. Current context: $(kubectl config current-context 2>/dev/null || echo 'No context set')"
            echo "2. Server URL: $(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}' 2>/dev/null || echo 'Unknown')"
            echo ""
            echo "ðŸš¨ Possible causes for EC2:"
            echo "- EC2 instance or Kubernetes cluster is down"
            echo "- Security groups blocking access"
            echo "- Kubeconfig server URL might be localhost/127.0.0.1 (needs to be EC2 internal IP)"
            echo "- Network connectivity issues between GitHub Actions and EC2"
            echo ""
            echo "ðŸ’¡ Solutions for different setups:"
            echo "- For minikube: Ensure minikube is running and accessible"
            echo "- For k3s: Check if k3s service is running: sudo systemctl status k3s"
            echo "- For kubeadm: Verify all control plane components are healthy"
            echo "- Check EC2 security groups allow access on Kubernetes API port (usually 6443)"
            echo ""
            echo "ðŸ”§ To fix kubeconfig server URL:"
            echo "Edit ~/.kube/config and replace 127.0.0.1 with your EC2 private IP"
            exit 1
          fi

      - name: Set deployment parameters
        id: params
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            RESOURCE_TYPE="${{ github.event.inputs.resource_type }}"
          else
            ENVIRONMENT="staging"  # Auto-deploy to staging for pushes
            RESOURCE_TYPE="all"
          fi
          
          # Use your actual namespaces
          if [ "$ENVIRONMENT" = "production" ]; then
            NAMESPACE="bedrock-chat-v2"
          else
            NAMESPACE="bedrock-chat-staging"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
          echo "resource_type=$RESOURCE_TYPE" >> $GITHUB_OUTPUT
          
          echo "ðŸš€ Infrastructure Deployment:"
          echo "- Environment: $ENVIRONMENT"
          echo "- Namespace: $NAMESPACE"
          echo "- Resource Type: $RESOURCE_TYPE"

      - name: Create namespace
        run: |
          kubectl create namespace ${{ steps.params.outputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -
          kubectl label namespace ${{ steps.params.outputs.namespace }} name=${{ steps.params.outputs.namespace }} --overwrite

      - name: Apply ConfigMaps
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'configmaps'
        run: |
          echo "ðŸ“‹ Applying ConfigMaps..."
          kubectl apply -f k8s/configmaps/app-config.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/configmaps/mysql-init.yaml -n ${{ steps.params.outputs.namespace }}
          
          echo "âœ… ConfigMaps applied:"
          kubectl get configmaps -n ${{ steps.params.outputs.namespace }}

      - name: Apply Secrets
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'secrets'
        run: |
          echo "ðŸ” Applying Secrets..."
          kubectl apply -f k8s/secrets/app-secrets.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/secrets/mysql-secrets.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/dockerhub-secrets.yaml -n ${{ steps.params.outputs.namespace }}
          
          echo "âœ… Secrets applied:"
          kubectl get secrets -n ${{ steps.params.outputs.namespace }}

      - name: Apply PVCs
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'statefulsets'
        run: |
          echo "ðŸ’¾ Applying PVCs..."
          kubectl apply -f k8s/pvc/file-uploads-pvc.yaml -n ${{ steps.params.outputs.namespace }}
          
          echo "âœ… PVCs applied:"
          kubectl get pvc -n ${{ steps.params.outputs.namespace }}

      - name: Deploy MySQL StatefulSet
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'statefulsets' || steps.params.outputs.resource_type == 'mysql-only'
        run: |
          echo "ðŸ—„ï¸ Deploying MySQL StatefulSet..."
          kubectl apply -f k8s/services/mysql-service.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/services/mysql-headless-service.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/statefulsets/mysql-statefulset.yaml -n ${{ steps.params.outputs.namespace }}
          
          echo "â³ Waiting for MySQL to be ready..."
          kubectl rollout status statefulset/mysql -n ${{ steps.params.outputs.namespace }} --timeout=600s || {
            echo "âš ï¸ MySQL rollout timeout, checking status..."
            kubectl get pods -l app=mysql -n ${{ steps.params.outputs.namespace }}
            kubectl describe statefulset mysql -n ${{ steps.params.outputs.namespace }}
            kubectl logs -l app=mysql -n ${{ steps.params.outputs.namespace }} --tail=20 || echo "No logs available"
          }

      - name: Apply Services
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'services'
        run: |
          echo "ðŸŒ Applying Microservice Services..."
          kubectl apply -f k8s/services/api-gateway-service.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/services/bedrock-service-service.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/services/file-service-service.yaml -n ${{ steps.params.outputs.namespace }}
          kubectl apply -f k8s/services/frontend-service.yaml -n ${{ steps.params.outputs.namespace }}
          
          # Apply NodePort service if exists
          if [ -f "k8s/services/frontend-nodeport.yaml" ]; then
            kubectl apply -f k8s/services/frontend-nodeport.yaml -n ${{ steps.params.outputs.namespace }}
          fi
          
          echo "âœ… Services applied:"
          kubectl get services -n ${{ steps.params.outputs.namespace }}

      - name: Apply Ingress (Production Only)
        if: (steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'ingress') && steps.params.outputs.environment == 'production'
        run: |
          echo "ðŸŒ Applying Ingress for Production..."
          if [ -f "k8s/ingress/bedrock-chat-ingress.yaml" ]; then
            kubectl apply -f k8s/ingress/bedrock-chat-ingress.yaml -n ${{ steps.params.outputs.namespace }}
            
            echo "âœ… Ingress applied:"
            kubectl get ingress -n ${{ steps.params.outputs.namespace }}
            kubectl describe ingress bedrock-chat-ingress -n ${{ steps.params.outputs.namespace }}
          else
            echo "âš ï¸ Ingress file not found, skipping..."
          fi

      - name: Apply Network Policies
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'network-policies'
        run: |
          echo "ðŸ”’ Applying Network Policies..."
          if [ -d "k8s/network-policies" ]; then
            kubectl apply -f k8s/network-policies/ -n ${{ steps.params.outputs.namespace }}
            
            echo "âœ… Network Policies applied:"
            kubectl get networkpolicies -n ${{ steps.params.outputs.namespace }}
          else
            echo "âš ï¸ Network policies directory not found, skipping..."
          fi

      - name: Apply HPA
        if: steps.params.outputs.resource_type == 'all' || steps.params.outputs.resource_type == 'hpa'
        run: |
          echo "ðŸ“ˆ Applying HPA..."
          if kubectl get apiservice v1beta1.metrics.k8s.io > /dev/null 2>&1; then
            if [ -d "k8s/hpa" ]; then
              kubectl apply -f k8s/hpa/ -n ${{ steps.params.outputs.namespace }}
              echo "âœ… HPA applied:"
              kubectl get hpa -n ${{ steps.params.outputs.namespace }}
            else
              echo "âš ï¸ HPA directory not found"
            fi
          else
            echo "âš ï¸ Metrics server not available, skipping HPA"
            # Try to install/fix metrics server
            echo "ðŸ”§ Applying custom metrics server..."
            if [ -f "k8s/metrics-server-custom.yaml" ]; then
              kubectl apply -f k8s/metrics-server-custom.yaml || echo "Metrics server apply failed"
            fi
          fi

      - name: Verify Infrastructure
        run: |
          echo "ðŸ” Verifying infrastructure deployment..."
          
          echo "=== Namespace ==="
          kubectl get namespace ${{ steps.params.outputs.namespace }}
          
          echo "=== ConfigMaps ==="
          kubectl get configmaps -n ${{ steps.params.outputs.namespace }}
          
          echo "=== Secrets ==="
          kubectl get secrets -n ${{ steps.params.outputs.namespace }}
          
          echo "=== PVCs ==="
          kubectl get pvc -n ${{ steps.params.outputs.namespace }}
          
          echo "=== StatefulSets ==="
          kubectl get statefulsets -n ${{ steps.params.outputs.namespace }}
          
          echo "=== Services ==="
          kubectl get services -n ${{ steps.params.outputs.namespace }}
          
          if [ "${{ steps.params.outputs.environment }}" = "production" ]; then
            echo "=== Ingress ==="
            kubectl get ingress -n ${{ steps.params.outputs.namespace }} || echo "No ingress found"
          fi
          
          echo "=== Network Policies ==="
          kubectl get networkpolicies -n ${{ steps.params.outputs.namespace }} || echo "No Network Policies"
          
          echo "=== HPA ==="
          kubectl get hpa -n ${{ steps.params.outputs.namespace }} || echo "No HPA"
          
          echo "=== All Pods ==="
          kubectl get pods -n ${{ steps.params.outputs.namespace }} -o wide

      - name: Run Infrastructure Health Checks
        run: |
          echo "ðŸ¥ Running infrastructure health checks..."
          
          # Check MySQL if deployed
          if kubectl get statefulset mysql -n ${{ steps.params.outputs.namespace }} > /dev/null 2>&1; then
            echo "Checking MySQL health..."
            if kubectl wait --for=condition=ready pod -l app=mysql -n ${{ steps.params.outputs.namespace }} --timeout=120s; then
              echo "âœ… MySQL is healthy"
            else
              echo "âš ï¸ MySQL health check failed"
              kubectl logs -l app=mysql -n ${{ steps.params.outputs.namespace }} --tail=20 || echo "No MySQL logs available"
            fi
          fi
          
          # Check services
          echo "Checking services..."
          kubectl get endpoints -n ${{ steps.params.outputs.namespace }}

      - name: Deployment summary
        if: always()
        run: |
          echo "## ðŸ—ï¸ Infrastructure Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ steps.params.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: ${{ steps.params.outputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Resource Type**: ${{ steps.params.outputs.resource_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" = "success" ]; then
            echo "âœ… **Infrastructure deployment completed successfully!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ðŸ“Š Deployed Resources" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            kubectl get all -n ${{ steps.params.outputs.namespace }} >> $GITHUB_STEP_SUMMARY 2>&1 || true
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Infrastructure deployment failed!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ðŸ” Troubleshooting" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            kubectl get events -n ${{ steps.params.outputs.namespace }} --sort-by='.lastTimestamp' | tail -15 >> $GITHUB_STEP_SUMMARY 2>&1 || true
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi
